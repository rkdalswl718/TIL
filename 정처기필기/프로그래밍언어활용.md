# 프로그래밍 언어 활용

 구조적 프로그래밍 설계 구조 및 절차
구조적 프로그래밍은 구조화 프로그래밍으로도 불리며 절차적 프로그래밍
기반 아래 만들어진 프로그래밍 기법으로 프로그램을 결합하는 순차, 분기,
반복 구조를 통하여 설계된다.

## 1. 구조적 프로그래밍 설계 구조
1. 순차구조
2. 선택구조(if, if-else)
3. 반복구조 (for, while)
![alt text](image.png)

## 2. 구조적 프로그래밍 언어 개발 절차
1. 요구사항 분석
2. 구조적 분석
3. 구조적 설계
4. 구조적 프로그래밍
  * 데이터 흐름도 DFD(Data Flow Diagram)
    1. 프로세스
      - 데이터 흐름(Data Flow)
      - 데이터 저장소(Data Store)
      - 외부 엔티티(External Entity)
    2. DFD 설계 방법
      1. 업무를 분석하여 프로세스에 대한 입출력 데이터 흐름을
식별한다. 이후 업무의 주변 경계에 그들을 표시한다.
      2. 데이터 흐름에 필요하고 제공되어야 할 외부 엔티티를 정의한다.
      3. 입력으로부터 출력으로나 출력으로부터 입력으로, 중간 지점부터의
데이터 흐름을 식별한다.
      4. 모든 접속 관계 데이터 흐름에 명칭을 부여한다.
      5. 프로세스에 대해 입력 데이터와 출력 데이터 흐름의 명칭에 따라
      이름을 부여한다.
      6. 프로세스에 관련된 데이터 저장소를 정의하고 검토, 보완한다.
      7. 상위 레벨 DFD 작성 후 다음 하위 레벨의 DFD로 분할하여 최하
      위 레벨까지 그린다.
      8. 데이터 흐름도의 규모가 커서 한 장의 종이에 그릴 수 없을 때는
      시스템을 서브 시스템들로 분할한다. 분할된 서브시스템들의 규모가 클
      때는 다시 분할을 계속한다. 세분화를 계속하여 최종 데이터 흐름도를
      단순한 기능들만으로 그릴 수 있는 단계까지 분할한다.
  * 자료사전 DD(Data Dictionary)
  * 상태 전이도 STD(State Transition Diagram)
  * 소단위 명세 Minispec(Mini Specification)

## 1-2 구조적 프로그래밍 언어 활용
1. 절차식 언어
  - 위에서 아래로 순서대로 실행
2. 명령어 언어
3. 함수 중심 언어
### 구조적 프로그래밍 유형
- c언어
- 파스칼
- 에이다
### 주요 구현 언어 문법
- 조건문(if, if~else, switch)
- 반복문 (for, while)

## 2. 객체지향 프로그래밍 언어 활용
### 객체 지향 설계 원칙의 이해
- 객체 지향 속성
  - 캡슐화
  - 추상화
  - 다형성
    - 오버로딩
    - 오버라이딩
  - 정보 은닉
  - 상속성
### 2. 객체지향 설계 원칙
1. 단일 책임 원칙 (Single Responsiblity Principle)
- 모든 클래스는 각각 하나의 책임만 가져야 한다.
- 클래스는 그 책임을 완전히 캡슐화해야 함을 말한다.
2. 개방-폐쇄 원칙 (Open Closed Principle)
- 확장에는 열려 있고 수정에는 닫혀 있어 기존의 코드를 변경하지 않고
(Closed), 기능을 추가할 수 있도록(Open) 설계가 되어야 한다는 원칙을
말한다.
3. 리스코프 치환 원칙 (Liskov Substitution Principle)
- 자식 클래스는 자신의 부모 클래스를 대체할 수 있다는 원칙이다.
- 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 작동해야 한다. 자식
클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행 하도록 해야 만족한다.
4. 인터페이스 분리 원칙 (Interface Segregation Principle)
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는
원칙이다. 하나의 평범한 인터페이스보다 여러 개의 구체적인 인터페이스
가 좋다.
5. 의존 역전 원칙 (Dependency Inversion Principle)
- 의존 역전 원칙은 변화가 없는 것에 의존해야 한다는 원칙이다. 구체적인
클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 하는 원칙이다