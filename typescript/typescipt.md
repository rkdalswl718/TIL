# 자바스크립트와 차이점

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/434740fb-eab5-4e66-8a89-8a935bf018dc/Untitled.png)

# 타입스크립트의 특징

### **컴파일 언어, 정적 타입 언어**

자바스크립트는 동적 타입의 인터프리터 언어로 런타임에서 오류를 발견할 수 있습니다. 이에 반해 타입스크립트는 정적 타입의 컴파일 언어이며 타입스크립트 컴파일러 또는 바벨(Babel)을 통해 자바스크립트 코드로 변환됩니다. 코드 작성 단계에서 타입을 체크해 오류를 확인할 수 있고 미리 타입을 결정하기 때문에 실행 속도가 매우 빠르다는 장점이 있습니다. 하지만 코드 작성 시 매번 타입을 결정해야 하기 때문에 번거롭고 코드량이 증가하며 컴파일 시간이 오래 걸린다는 단점이 있습니다.

### **자바스크립트 슈퍼셋(Superset)**

타입스크립트는 자바스크립트의 슈퍼셋, 즉 자바스크립트 기본 문법에 타입스크립트의 문법을 추가한 언어입니다. 따라서 유효한 자바스크립트로 작성한 코드는 확장자를 .js에서 .ts로 변경하고 타입스크립트로 컴파일해 변환할 수 있습니다.

### **객체 지향 프로그래밍 지원**

타입스크립트는 ES6(ECMAScript 6)에서 새롭게 사용된 문법을 포함하고 있으며 클래스, 인터페이스, 상속, 모듈 등과 같은 객체 지향 프로그래밍 패턴을 제공합니다.

# **타입스크립트 사용을 고려해야 하는 이유**

### **높은 수준의 코드 탐색과 디버깅**

타입스크립트는 코드에 목적을 명시하고 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거합니다. 또한 코드 자동완성이나 실행 전 피드백을 제공하여 작업과 동시에 디버깅이 가능해 생산성을 높일 수 있습니다. 실제로 한 연구에 따르면 모든 자바스크립트 버그의 15%가 사전에 타입스크립트로 감지할 수 있다고 합니다.

### **자바스크립트 호환**

타입스크립트는 자바스크립트와 100% 호환됩니다. 따라서 프론트엔드 또는 백엔드 어디든 자바스크립트를 사용할 수 있는 곳이라면 타입스크립트도 쓸 수 있습니다. 타입스크립트는 앱과 웹을 구현하는 자바스크립트와 동일한 용도로 사용 가능하며 서버 단에서 개발이 이루어지는 복잡한 대형 프로젝트에서도 빛을 발합니다.

### **강력한 생태계**

타입스크립트는 그리 오래되지 않은 언어임에도 불구하고 강력한 생태계를 가지고 있습니다. 대부분의 라이브러리들이 타입스크립트를 지원하며 마이크로소프트의 비주얼 스튜디오 코드(VSCode)를 비롯해 각종 에디터가 타입스크립트 관련 기능과 플러그인을 지원합니다.

### **점진적 전환 가능**

기존의 자바스크립트 프로젝트를 타입스크립트로 전환하는데 부담이 있다면 추가 기능이나 특정 기능에만 타입스크립트를 도입함으로써 프로젝트를 점진적으로 전환할 수 있습니다. 자바스크립트에 주석을 추가하는 것에서부터 시작해 시간이 지남에 따라 코드베이스가 완전이 바뀌도록 준비 기간을 가질 수 있습니다.

하지만, 새로운 프로그래밍 언어에 대한 러닝 커브(Learning Curve), 상대적으로 낮은 가독성, 코드량 증가 등의 이유로 타입스크립트 사용을 망설이는 개발자가 많습니다. 프로젝트 성격에 따라 타입스크립트를 사용할지 결정하면 됩니다. 프로젝트의 규모가 크고 복잡할수록, 유지보수가 중요한 장기 프로젝트일수록 타입스크립트의 이점이 부각될 것입니다.

### 타입스크립트의 대표 타입 12가지

```tsx
- boolean // true, false 논리값
- number  // 실수, 정수
- string  // 문자
- object  // 객체
- array   // 배열
- tuple   // 튜플. 고정된 요소 수와 각 요소의 타입이 정해진 배열 타입.
- enum    // 열거형. 숫자 또는 문자열 값 집합을 나타냄
- any     // 모든 타입허용. 쓰지않는게 좋음(자바스크립트와 다른 점이 없기 때문) 
- void    // 리턴이 없는 함수
- null    // null
- undefined //undefined
- never   // 불가능을 명시
```

### 타입 주석(Type Annotations)

타입스크립트 코드에서 변수, 매개변수, 함수, 클래스 등의 요소에 대해 명시적으로 타입 정보를 제공하는 것을 말합니다. 타입 주석은 콜론(**`:`**)을 사용하여 변수나 함수 이름 뒤에 타입을 기술하는 방식으로 작성합니다.

```tsx
// 변수에 타입 주석
let age: number;

//함수에 타입 주석
const add = (a: number, b: number): number => {
  return a + b;
};
```

### 타입 추론(Type inference)

타입스크립트 컴파일러가 변수의 타입을 코드를 분석하여 자동으로 추론하는 기능을 말합니다. 타입을 명시하지 않은 상태에서 값이 할당되거나 지정된 상태에서 이루어 집니다.

```tsx
let a = 10 // 자동으로 number 타입으로 추론됩니다.
let b: string = 'hi' // string 타입으로 명시합니다.

a = 'hello' // X (error)
b = 'world' // O
b = 100 // X (error)
.
.
.
const add = (a: number, b: number) => {
  return a + b;
}
// add 함수의 반환값은 자동으로 number 타입으로 추론됩니다.

const person = { name: "Alice", age: 30 };
// person 객체의 타입은 { name: string, age: number }로 추론됩니다.
```

주석과 추론을 통해 지정된 타입을 벗어난 동작을 시도하면 오류가 발생합니다. 타입 추론은 코드를 간결하고 유연하게 작성할 수 있도록 도와주며, 명시적인 타입 주석을 작성하지 않아도 타입스크립트가 타입을 유추할 수 있는 경우 편리합니다. 그러나 때때로 타입스크립트가 원하는 타입을 정확하게 추론하지 못하는 경우도 있을 수 있습니다. 이런 경우에는 명시적으로 타입 주석을 추가하여 원하는 타입을 명확하게 지정할 수 있습니다.

### **인터페이스(interface)**

타입스크립트에서 객체의 구조를 정의하는 역할을 하는 기능입니다. 객체가 어떤 프로퍼티와 메서드를 가져야 하는지를 명세하는데 사용됩니다.

```tsx
// Person 인터페이스 정의
interface Person {
  name: string;
  age: number;
  sayHello(): void;
}

// Person 인터페이스를 따르는 객체 생성
const person1: Person = {
  name: "Alice",
  age: 30,
  sayHello: () => {
    console.log("Hello!");
  },
};

const person2: Person = {
  name: "Bob",
  age: 25,
  sayHello: () => {
    console.log("Hi!");
  },
};
```

### 인터페이스 확장(Interface Extension)

이미 정의된 인터페이스에 새로운 프로퍼티 또는 메서드를 추가하는 기능을 말합니다. 이를 통해 기존 인터페이스를 확장하여 새로운 인터페이스를 만들 수 있습니다.

인터페이스를 확장하는 방법은 **`extends`** 키워드를 사용하여 기존 인터페이스를 참조하고, 새로운 프로퍼티나 메서드를 추가하면 됩니다. 확장된 인터페이스는 기존 인터페이스의 모든 프로퍼티와 메서드를 포함하며, 추가로 정의한 프로퍼티와 메서드를 가지게 됩니다.

```tsx
interface Animal {
	type: string
}

interface Cat extends Animal {
	place: string
	feed: string
}
```

⬇️⬇️⬇️

```tsx
interface Cat {
	type: string
	place: string
	feed: strin
```

### **제네릭 타입(generics)**

타입스크립트에서 함수, 클래스, 인터페이스 등을 정의할 때, 타입이 고정되지 않고 여러 종류의 타입을 지원할 수 있도록 하는 기능입니다. 즉, 제네릭을 사용하면 함수나 클래스의 입력 데이터 타입이 유연하게 결정되어 재사용성을 높일 수 있습니다.

제네릭은 **`<T>`**와 같은 형태로 표현되며, **`T`**는 타입 파라미터(Type Parameter)라고 부릅니다. 이 타입 파라미터는 함수나 클래스가 호출되거나 인스턴스화될 때 실제 타입으로 대체됩니다.

```tsx
const echo = <T>(data: T): T => {
  return data;
};

const result1 = echo<string>("Hello, Generics!"); // result1의 타입은 string
const result2 = echo<number>(12345); // result2의 타입은 number
```